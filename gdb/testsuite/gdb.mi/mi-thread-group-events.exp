# Copyright 2016 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

load_lib mi-support.exp
load_lib trace-support.exp
set MIFLAGS "-i=mi"

standard_testfile

# Compile binaries for the multiple tests of this file.

foreach suffix { "run" "fork" "attach" "trace" } {
    set binfile_varname "binfile_${suffix}"
    set srcfile_varname "srcfile_${suffix}"

    set binfile_value "${binfile}-${suffix}"
    set srcfile_value "[file rootname ${srcfile}]-${suffix}[file extension ${srcfile}]"

    set $binfile_varname $binfile_value
    set $srcfile_varname $srcfile_value

    if  { [gdb_compile "${srcdir}/${subdir}/${srcfile_value}" "${binfile_value}" executable {debug}] != "" } {
	untested ${testfile}
	return -1
    }
}

# Restart with a clean gdb, loading file BINFILE.

proc init_gdb { binfile } {
    global srcdir
    global subdir

    gdb_exit
    mi_gdb_start

    mi_delete_breakpoints
    mi_gdb_reinitialize_dir $srcdir/$subdir
    mi_gdb_load ${binfile}
}

# Test the =thread-group-started event when doing a "run".

proc test_thread_group_started_run {} {
    global decimal
    global binfile_run
    global srcfile_run

    init_gdb ${binfile_run}

    # stub-like targets don't support running.
    if [use_gdb_stub] {
	return
    }

    if [mi_is_target_remote] {
	set target_path [gdbserver_download_current_prog]

	mi_gdb_test "set remote exec-file $target_path" ".*\\^done" "set remote exec-file"
    }

    mi_gdb_test \
	"111-exec-run --start" \
	".*=thread-group-started,id=\"i1\",pid=\"${decimal}\",reason=\"run\".*" \
	"thread-group-started event"

    mi_expect_stop "breakpoint-hit" "main" "" ".*${srcfile_run}.*" "\[0-9\]+" \
	{ "" "disp=\"del\"" } "stop at main"
}

# Test the =thread-group-exited event when letting the program run to
# completion.

proc test_thread_group_exited_normal {} {
    global decimal
    global binfile_run
    global srcfile_run

    init_gdb ${binfile_run}

    mi_runto "main"

    if [use_gdb_stub] {
	set reason "disconnect"
    } else {
	set reason "normal"
    }

    # Continue until normal end of program.
    mi_send_resuming_command "exec-continue" "continue until end"

    # Confirm that we get the right thread-group-exited event.
    set test "thread-group-exited event"
    gdb_test_multiple "" $test {
	-re "=thread-group-exited,id=\"i1\",exit-code=\"0\",reason=\"$reason\"" {
	    pass $test
	}
    }
}

# Test the =thread-group-started/-exit event when attaching and detaching.

proc test_thread_group_events_attach_detach {} {
    global binfile_attach

    init_gdb ${binfile_attach}

    # We can't attach if we can't spawn a process.
    if { ![can_spawn_for_attach] } {
	return
    }

    set test_spawn_id [spawn_wait_for_attach ${binfile_attach}]
    set test_pid [spawn_id_get_pid ${test_spawn_id}]

    mi_gdb_test \
	"-target-attach ${test_pid}" \
	".*=thread-group-started,id=\"i1\",pid=\"${test_pid}\",reason=\"attach\".*" \
	"attach"

    mi_gdb_test \
	"-target-detach" \
	".*=thread-group-exited,id=\"i1\",reason=\"detach\".*" \
	"detach"
}

# Test the =thread-group-started/-exited events when debugging a core file.

proc test_thread_group_events_core {} {
    global binfile_run
    global decimal

    set corefile [standard_output_file "corefile"]
    set corefile_re [string_to_regexp ${corefile}]

    init_gdb ${binfile_run}

    mi_runto "main"

    mi_gdb_test "gcore ${corefile}" \
	".*Saved corefile ${corefile_re}.*" \
	"generate core"

    mi_gdb_test \
	"-target-select core ${corefile}" \
	".*=thread-group-started,id=\"i1\",pid=\"$decimal\",reason=\"core\".*" \
	"load core"

    # Giving an unexisting path to "-target-select core" causes the previous
    # core file to get closed, so it's enough for our test.
    mi_gdb_test \
	"-target-select core foo" \
	".*=thread-group-exited,id=\"i1\",reason=\"core\".*" \
	"unload core"
}

# Test the =thread-group-started/-exited events when loading/unloading a trace
# file.

proc test_thread_group_events_trace {} {
    global binfile_trace
    global srcfile_trace
    global decimal

    set break_line [gdb_get_line_number "after tracing" "${srcfile_trace}"]
    set tracefile [standard_output_file "tracefile"]

    init_gdb ${binfile_trace}

    # This needs to be before mi_target_supports_trace.
    mi_runto "main"

    if { ![mi_target_supports_trace] } {
	unsupported "trace tests"
	return
    }

    # Start by generating a tracefile.
    mi_gdb_test "-break-insert -a tracee" ".*type=\"tracepoint\".*" "insert tracepoint"
    mi_gdb_test "888-trace-start" ".*888\\^done" "start tracing"
    mi_continue_to_line ${break_line} "continue"
    mi_gdb_test "999-trace-stop" ".*999\\^done.*" "stop tracing"
    mi_gdb_test "564-trace-save ${tracefile}" "564\\^done" "save trace"

    # Then load the tracefile, and confirm that we see the event.
    mi_gdb_test \
	"-target-select tfile ${tracefile}" \
	".*=thread-group-started,id=\"i1\",pid=\"$decimal\",reason=\"trace\".*" \
	"load trace"

    # Giving an unexisting path to "-target-select core" causes the previous
    # target (the trace file) file to get closed, so it's enough for our test.
    mi_gdb_test \
	"-target-select core foo" \
	".*=thread-group-exited,id=\"i1\",reason=\"trace\".*" \
	"unload trace"
}

# Test the =thread-group-started event when the inferior forks.

proc test_thread_group_started_fork {} {
    global binfile_fork
    global srcfile_fork
    global decimal

    set fork_line [gdb_get_line_number "fork line" ${srcfile_fork}]

    init_gdb ${binfile_fork}

    # We need detach-on-fork off in order to have a second inferior created at
    # the fork.
    mi_gdb_test "411-gdb-set detach-on-fork off" "411\\^done" "unset detach-on-fork"

    # Get to the fork() line.
    mi_runto "main"
    mi_continue_to_line "${srcfile_fork}:${fork_line}" "insert breakpoint at fork line"


    # Step over the fork()
    mi_send_resuming_command "exec-next" "next over fork"

    # Confirm that we got the right event.
    set test "second thread group started"
    gdb_test_multiple "" $test {
	-re "=thread-group-started,id=\"i2\",pid=\"${decimal}\",reason=\"fork\"" {
	    pass $test
	}
    }
}

test_thread_group_started_run
test_thread_group_exited_normal
test_thread_group_events_attach_detach
test_thread_group_events_trace
test_thread_group_started_fork
test_thread_group_events_core

